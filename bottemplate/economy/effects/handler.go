package effects

import (
	"context"
	"time"
)

// EffectType defines the type of effect
type EffectType string

const (
	EffectTypeActive  EffectType = "active"
	EffectTypePassive EffectType = "passive"
)

// EffectCategory defines the category of effect for organization
type EffectCategory string

const (
	EffectCategoryDaily      EffectCategory = "daily"
	EffectCategoryClaim      EffectCategory = "claim"
	EffectCategoryEconomy    EffectCategory = "economy"
	EffectCategoryCollection EffectCategory = "collection"
	EffectCategoryQuest      EffectCategory = "quest"
	EffectCategoryEffect     EffectCategory = "effect"
	EffectCategoryUtility    EffectCategory = "utility"
)

// EffectMetadata contains metadata about an effect
type EffectMetadata struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Type        EffectType     `json:"type"`
	Category    EffectCategory `json:"category"`
	Cooldown    time.Duration  `json:"cooldown"`
	MaxUses     int            `json:"max_uses"`
	Animated    bool           `json:"animated"`
	Tags        []string       `json:"tags"`
	Version     string         `json:"version"`
}

// EffectParams contains parameters for effect execution
type EffectParams struct {
	UserID    string                 `json:"user_id"`
	Arguments string                 `json:"arguments"`
	Context   map[string]interface{} `json:"context"`
	Metadata  *EffectMetadata        `json:"metadata"`
}

// EffectResult contains the result of effect execution
type EffectResult struct {
	Success  bool                   `json:"success"`
	Message  string                 `json:"message"`
	ImageURL string                 `json:"image_url,omitempty"`
	Data     map[string]interface{} `json:"data,omitempty"`
	Consumed bool                   `json:"consumed"` // Whether the effect was consumed
	Cooldown *time.Time             `json:"cooldown,omitempty"`
	Events   []EffectEvent          `json:"events,omitempty"`
	Metrics  *EffectMetrics         `json:"metrics,omitempty"`
}

// EffectEvent represents an event generated by effect execution
type EffectEvent struct {
	Type      string                 `json:"type"`
	UserID    string                 `json:"user_id"`
	EffectID  string                 `json:"effect_id"`
	Timestamp time.Time              `json:"timestamp"`
	Data      map[string]interface{} `json:"data"`
}

// EffectMetrics contains metrics about effect execution
type EffectMetrics struct {
	ExecutionTime time.Duration `json:"execution_time"`
	ResourcesUsed []string      `json:"resources_used,omitempty"`
	Impact        float64       `json:"impact,omitempty"`
}

// EffectValidationError represents validation errors for effects
type EffectValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
	Code    string `json:"code"`
}

func (e EffectValidationError) Error() string {
	return e.Message
}

// EffectHandler defines the interface for all effect handlers
type EffectHandler interface {
	// Execute runs the effect with given parameters
	Execute(ctx context.Context, params EffectParams) (*EffectResult, error)

	// Validate checks if the effect can be executed with given parameters
	Validate(ctx context.Context, params EffectParams) []EffectValidationError

	// GetMetadata returns metadata about this effect
	GetMetadata() EffectMetadata

	// CanExecute checks if the effect can be executed (cooldown, prerequisites, etc.)
	CanExecute(ctx context.Context, userID string) (bool, string)

	// EstimateCost estimates the cost/impact of executing this effect
	EstimateCost(ctx context.Context, params EffectParams) (map[string]interface{}, error)
}

// PassiveEffectHandler defines the interface for passive effects
type PassiveEffectHandler interface {
	EffectHandler

	// ApplyEffect applies the passive effect to a game action
	ApplyEffect(ctx context.Context, userID string, action string, baseValue interface{}) (interface{}, error)

	// IsActive checks if the passive effect is currently active for a user
	IsActive(ctx context.Context, userID string) (bool, error)

	// GetModifier returns the modifier value for this passive effect
	GetModifier(ctx context.Context, userID string, action string) (float64, error)
}

// ActiveEffectHandler defines the interface for active effects
type ActiveEffectHandler interface {
	EffectHandler

	// GetCooldown returns the cooldown duration for this effect
	GetCooldown(ctx context.Context, userID string) (time.Duration, error)

	// ConsumeUse decrements the use count for this effect (if applicable)
	ConsumeUse(ctx context.Context, userID string) error

	// GetRemainingUses returns remaining uses for this effect
	GetRemainingUses(ctx context.Context, userID string) (int, error)
}

// EffectDependencies provides access to game systems for effects
type EffectDependencies struct {
	UserRepo       interface{}
	CardRepo       interface{}
	UserCardRepo   interface{}
	AuctionRepo    interface{}
	EffectRepo     interface{}
	CollectionRepo interface{}
	Database       interface{}
}

// BaseEffectHandler provides common functionality for all effects
type BaseEffectHandler struct {
	metadata EffectMetadata
	deps     *EffectDependencies
}

// NewBaseEffectHandler creates a new base effect handler
func NewBaseEffectHandler(metadata EffectMetadata, deps *EffectDependencies) *BaseEffectHandler {
	return &BaseEffectHandler{
		metadata: metadata,
		deps:     deps,
	}
}

// GetMetadata returns the effect metadata
func (b *BaseEffectHandler) GetMetadata() EffectMetadata {
	return b.metadata
}

// GetDependencies returns the effect dependencies
func (b *BaseEffectHandler) GetDependencies() *EffectDependencies {
	return b.deps
}

// CanExecute provides basic cooldown checking
func (b *BaseEffectHandler) CanExecute(ctx context.Context, userID string) (bool, string) {
	// Basic implementation - can be overridden
	return true, ""
}

// EstimateCost provides basic cost estimation
func (b *BaseEffectHandler) EstimateCost(ctx context.Context, params EffectParams) (map[string]interface{}, error) {
	// Basic implementation - can be overridden
	return map[string]interface{}{}, nil
}

// Validate provides basic validation
func (b *BaseEffectHandler) Validate(ctx context.Context, params EffectParams) []EffectValidationError {
	var errors []EffectValidationError

	if params.UserID == "" {
		errors = append(errors, EffectValidationError{
			Field:   "user_id",
			Message: "user ID is required",
			Code:    "MISSING_USER_ID",
		})
	}

	return errors
}
